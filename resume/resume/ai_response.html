<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://cdn.jsdelivr.net/npm/@n8n/chat/dist/style.css" rel="stylesheet" />
    <title>AI Response Viewer</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            margin-right: 40%;
            /* match the panel width */
            background-color: #f9f9f9;
            color: #030d1b;
        }

        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: #82858a;
            border-bottom: 1px solid #ffffff
        }

        main {
            padding: 1rem 1.25rem
        }

        pre {
            background: #0f172a;
            border: 1px solid #1e293b;
            border-radius: 10px;
            padding: 1rem;
            overflow: auto
        }

        .btn {
            padding: .5rem .75rem;
            border: 1px solid #334155;
            border-radius: 8px;
            background: #0b1220;
            color: #fdfeff;
            cursor: pointer
        }

        /* #n8n-chat {
            width: 380px;
            height: 90%;
        } */

        .chat-panel {
            position: fixed;
            top: 5%;
            bottom: 10%;
            right: 0;
            width: 40%;
            /* adjust as needed */
            height: 90%;
            background: #fff;
            /* chat background inherits from n8n styles */
            border-left: 1px solid #e2e8f0;
            z-index: 9999;
            /* on top of other content */
        }
    </style>
</head>

<body>
    <div id="header-placeholder"></div>
    <header>
        <div id="title">AI Response</div>
        <div>
            <button class="btn" id="copyBtn">Copy JSON</button>
            <button class="btn" id="downloadBtn">Download JSON</button>
        </div>


    </header>

    <!--AI Responses  -->
    <h1>AI Responses</h1>
    <p class="muted">Analyzed resume responses are stored locally (IndexedDB). Latest appears first, only 10 kept.
    </p>
    <div class="box" style="margin:.75rem 0 1rem">
        <select id="respSelect" aria-label="Saved responses">
            <option value="" selected disabled>-- Select a saved response --</option>
        </select>
        <button id="respViewBtn">View</button>
        <button id="respRenameBtn">Rename</button>
        <button id="respDeleteBtn" class="danger">Delete</button>
        <button id="respRefreshBtn">Refresh</button>
    </div>

    <!-- <div class="row">
        <button id="respSimulatePost" class="primary">Simulate POST ‚Üí Save</button>
        <span id="status" class="muted"></span>
    </div> -->

    <!-- AI Responses -->

    <div class="container" id="analysis-section"
        style="font-family: 'Inter', sans-serif; max-width: 1000px; margin: auto; padding: 2rem; background: #ffffff; border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.05);">
    </div>

    <!-- Chat container -->
    <div id="n8n-chat" class="chat-panel"></div>
    <script type="module">
        // Load header once (IDs must be unique; ensure only one #header-placeholder)
        fetch("/reusables/header.html")
            .then(res => res.text())
            .then(html => { document.getElementById("header-placeholder").innerHTML = html; })
            .catch(console.error);

        // ---------- Utilities ----------
        const formatBytes = (n) => {
            if (n == null) return '‚Äî';
            const u = ['B', 'KB', 'MB', 'GB']; let i = 0;
            while (n >= 1024 && i < u.length - 1) { n /= 1024; i++; }
            return `${(n < 10 && i > 0) ? n.toFixed(1) : Math.round(n)} ${u[i]}`;
        };
        const fmtDate = (d) => new Date(d).toLocaleString();

        // ---------- Responses DB (AI_response/responses) ----------
        const responseDB = (() => {
            const DB_NAME = 'AI_response';
            const STORE = 'responses';
            let db;

            function open() {
                return new Promise((resolve, reject) => {
                    if (db) return resolve(db);
                    const req = indexedDB.open(DB_NAME, 1);
                    req.onupgradeneeded = (e) => {
                        const _db = e.target.result;
                        if (!_db.objectStoreNames.contains(STORE)) {
                            const os = _db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
                            os.createIndex('created', 'created', { unique: false });
                        }
                    };
                    req.onsuccess = () => { db = req.result; resolve(db); };
                    req.onerror = () => reject(req.error);
                });
            }

            function tx(mode = 'readonly') {
                const t = db.transaction(STORE, mode);
                return [t, t.objectStore(STORE)];
            }

            async function add(payload, label) {
                await open();
                return new Promise((resolve, reject) => {
                    const now = Date.now();
                    const [t, s] = tx('readwrite');
                    const rec = {
                        label: label || deriveTitle(payload) || 'AI Response',
                        created: now,
                        data: payload
                    };
                    const req = s.add(rec);
                    req.onsuccess = async () => { await trimToMax(10); resolve(req.result); };
                    req.onerror = () => reject(req.error);
                });
            }

            async function all() {
                await open();
                return new Promise((resolve, reject) => {
                    const [t, s] = tx('readonly');
                    const r = s.getAll();
                    r.onsuccess = () => resolve(r.result || []);
                    r.onerror = () => reject(r.error);
                });
            }

            async function get(id) {
                await open();
                return new Promise((resolve, reject) => {
                    const [t, s] = tx('readonly');
                    const r = s.get(id);
                    r.onsuccess = () => resolve(r.result || null);
                    r.onerror = () => reject(r.error);
                });
            }

            async function updateLabel(id, newLabel) {
                await open();
                return new Promise((resolve, reject) => {
                    const [t, s] = tx('readwrite');
                    const getReq = s.get(id);
                    getReq.onsuccess = () => {
                        const rec = getReq.result;
                        if (!rec) return reject(new Error('Not found'));
                        rec.label = newLabel;
                        const putReq = s.put(rec);
                        putReq.onsuccess = () => resolve(true);
                        putReq.onerror = () => reject(putReq.error);
                    };
                    getReq.onerror = () => reject(getReq.error);
                });
            }

            async function remove(id) {
                await open();
                return new Promise((resolve, reject) => {
                    const [t, s] = tx('readwrite');
                    const req = s.delete(id);
                    req.onsuccess = () => resolve(true);
                    req.onerror = () => reject(req.error);
                });
            }

            async function trimToMax(max) {
                const items = await all();
                if (items.length <= max) return true;
                items.sort((a, b) => (a.created || 0) - (b.created || 0)); // oldest first
                await open();
                return new Promise((resolve) => {
                    const [t, s] = tx('readwrite');
                    const toDelete = items.length - max;
                    for (let i = 0; i < toDelete; i++) s.delete(items[i].id);
                    t.oncomplete = () => resolve(true);
                });
            }

            function deriveTitle(json) {
                if (json?.analysis?.overall_match) return json.analysis.overall_match.slice(0, 60);
                if (json?.title) return json.title;
                return `AI Response ‚Äì ${new Date().toLocaleString()}`;
            }

            return { open, add, all, get, updateLabel, remove };
        })();

        // ---------- Responses UI ----------
        const respSelect = document.getElementById('respSelect');
        const respViewBtn = document.getElementById('respViewBtn');
        const respRenameBtn = document.getElementById('respRenameBtn');
        const respDeleteBtn = document.getElementById('respDeleteBtn');
        const respRefreshBtn = document.getElementById('respRefreshBtn');
        // const simulateBtn = document.getElementById('respSimulatePost');
        const statusEl = document.getElementById('status');

        async function renderResponsesDropdown(selectedId = null) {
            await responseDB.open();
            const rows = await responseDB.all();
            rows.sort((a, b) => (b.created || 0) - (a.created || 0));
            respSelect.innerHTML = '<option value="" selected disabled>-- Select a saved response --</option>';
            for (const r of rows) {
                const opt = document.createElement('option');
                opt.value = String(r.id);
                opt.textContent = `${r.label} ‚Ä¢ ${new Date(r.created).toLocaleString()}`;
                respSelect.appendChild(opt);
            }
            if (selectedId) {
                const found = [...respSelect.options].find(o => Number(o.value) === selectedId);
                if (found) found.selected = true;
            }
        }

        respViewBtn.addEventListener('click', async () => {
            const id = Number(respSelect.value);
            if (!id) return alert('Choose a saved response.');
            // Update the address bar (no reload) ‚Ä¶
            const url = new URL(location.href);
            url.searchParams.set('id', id);
            history.replaceState({}, '', url);

            let rec = null;

            if (id) {
                rec = await getById(id);
            } else {
                // No id in URL ‚Üí load latest
                const rows = await getAll();
                if (rows.length) {
                    rows.sort((a, b) => (b.created || 0) - (a.created || 0));
                    rec = rows[0];
                    id = rec.id;
                    history.replaceState({}, '', `?id=${encodeURIComponent(id)}`);
                }
            }

            if (!rec) { out.textContent = 'No saved responses.'; return; }

            title.textContent = `${rec.label || 'AI Response'} ‚Ä¢ ${new Date(rec.created).toLocaleString()}`;
            const text = renderAnalysis(rec.data);
            out.textContent = text;

            // renderAnalysis(rec.data);

            // ‚Ä¶then re-render the page for this id
            // await loadById(id); // call your function that reads from IDB and renders
        });

        respRenameBtn.addEventListener('click', async () => {
            const id = Number(respSelect.value);
            if (!id) return alert('Select a response to rename.');
            const currentOpt = respSelect.options[respSelect.selectedIndex]?.textContent || '';
            const currentLabel = currentOpt.split(' ‚Ä¢ ')[0];
            const newLabel = prompt('New label:', currentLabel);
            if (!newLabel?.trim()) return;
            await responseDB.updateLabel(id, newLabel.trim());
            await renderResponsesDropdown(id);
        });

        respDeleteBtn.addEventListener('click', async () => {
            const id = Number(respSelect.value);
            if (!id) return alert('Select a response to delete.');
            if (!confirm('Delete this saved response? This cannot be undone.')) return;
            await responseDB.remove(id);
            await renderResponsesDropdown();
        });

        // simulateBtn.addEventListener('click', async () => {
        //     statusEl.textContent = 'Submitting‚Ä¶';
        //     try {
        //         const json = {
        //             analysis: { overall_match: 'Strong Azure + Spark alignment' },
        //             match_percentage: Math.floor(Math.random() * 20) + 70,
        //             created_at: new Date().toISOString()
        //         };
        //         const newId = await responseDB.add(json);
        //         await renderResponsesDropdown(newId);
        //         statusEl.textContent = 'Saved ‚úî';
        //         setTimeout(() => (statusEl.textContent = ''), 1500);
        //     } catch (e) {
        //         console.error(e);
        //         statusEl.textContent = 'Failed to save: ' + e;
        //     }
        // });

        // ---------- Init ----------
        (async () => {
            await responseDB.open();
            await renderResponsesDropdown();
        })();


        const DB_NAME = 'AI_response', STORE = 'responses';
        let db;

        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = (e) => {
                    const _db = e.target.result;
                    if (!_db.objectStoreNames.contains(STORE)) {
                        _db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
                    }
                };
                req.onsuccess = () => { db = req.result; resolve(db); };
                req.onerror = () => reject(req.error);
            });
        }

        function getById(id) {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readonly');
                const store = tx.objectStore(STORE);
                const r = store.get(id);
                r.onsuccess = () => resolve(r.result || null);
                r.onerror = () => reject(r.error);
            });
        }

        function getAll() {
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE, 'readonly');
                const store = tx.objectStore(STORE);
                const r = store.getAll();
                r.onsuccess = () => resolve(r.result || []);
                r.onerror = () => reject(r.error);
            });
        }

        function getParam(name) {
            const url = new URL(window.location.href);
            return url.searchParams.get(name);
        }

        const out = document.getElementById('jsonOut');
        const title = document.getElementById('title');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        const analysisSection = document.getElementById('analysis-section');

        function renderAnalysis(analysisData) {
            function createList(items) {
                return '<ul style="padding-left: 1.25rem;">' + items.map(i => `<li>${i}</li>`).join('') + '</ul>';
            }

            const container = document.getElementById("analysis-section");
            container.innerHTML = `
            <h2 style="color: #7c3aed;">üîç Overall Match Summary</h2>
            <p>${analysisData.overall_match}</p>

            <h3 style="color: #4c1d95;">‚úÖ Skills & Experience Found in Both</h3>
            ${createList(analysisData.key_skills_exp_phrases_found_in_both)}

            <h3 style="color: #b91c1c;">‚ùå Missing but Important for Job</h3>
            ${createList(analysisData.key_skills_exp_phrases_missing_from_resume_but_important_in_job)}

            <h3 style="color: #0f766e;">üìä Match Score: <span style="font-size: 1.5rem; font-weight: 600;">${analysisData.match_percentage}%</span></h3>
            <p>${analysisData.match_percentage_explanation}</p>

            <h3 style="color: #3b0764;">‚≠ê Rating: ${analysisData.rating}/5</h3>
            <p>${analysisData.rating_justification}</p>

            <h3 style="color: #1e3a8a;">üìÑ Tailored ATS-Optimized Resume</h3>
            <pre style="
  background:#f9fafb; padding:1rem; border-radius:8px; margin-bottom:2rem;
  font-size:.95rem; line-height:1.4;
  white-space: pre-wrap;        /* preserve newlines, wrap long lines   */
  overflow-wrap: anywhere;
  word-wrap: break-word;        /* fallback for older browsers          */
  overflow-x: hidden;           /* no horizontal scroll                 */
  max-width: 100%;
">${analysisData.tailored_ats_optimized_resume}</pre>

            <h3 style="color: #4b5563;">üí° Summary & Tips</h3>
            <p>${analysisData.summary_and_tips}</p>

            <h3 style="color: #ca8a04;">üõ†Ô∏è Optional Suggestions</h3>
            ${createList(analysisData.optional_suggestions)}
        `;
        }

        (async function init() {
            await openDB();

            let id = Number(getParam('id'));
            let rec = null;

            if (id) {
                rec = await getById(id);
            } else {
                // No id in URL ‚Üí load latest
                const rows = await getAll();
                if (rows.length) {
                    rows.sort((a, b) => (b.created || 0) - (a.created || 0));
                    rec = rows[0];
                    id = rec.id;
                    history.replaceState({}, '', `?id=${encodeURIComponent(id)}`);
                }
            }

            if (!rec) { out.textContent = 'No saved responses.'; return; }

            title.textContent = `${rec.label || 'AI Response'} ‚Ä¢ ${new Date(rec.created).toLocaleString()}`;
            const text = renderAnalysis(rec.data);
            // out.textContent = text;

            // renderAnalysis(rec.data);

            copyBtn.onclick = async () => {
                try { await navigator.clipboard.writeText(text); copyBtn.textContent = 'Copied!'; setTimeout(() => copyBtn.textContent = 'Copy JSON', 1200); } catch { }
            };
            downloadBtn.onclick = () => {
                const blob = new Blob([text], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `ai-response-${id}.json`;
                document.body.appendChild(a); a.click(); a.remove();
                setTimeout(() => URL.revokeObjectURL(a.href), 5000);
            };
        })();

        const N8N_CHAT_WEBHOOK = 'https://n8n.srv968815.hstgr.cloud/webhook/4450ff2e-9167-455d-b7e9-92ad7a398c13/chat'; // <-- change me


        import { createChat } from 'https://cdn.jsdelivr.net/npm/@n8n/chat/dist/chat.bundle.es.js';

        async function syncCurrentFromURL() {
            await openDB();
            let id = Number(getParam('id'));
            let rec = null;

            if (id) {
                rec = await getById(id);
            } else {
                // No id in URL ‚Üí load latest
                const rows = await getAll();
                if (rows.length) {
                    rows.sort((a, b) => (b.created || 0) - (a.created || 0));
                    rec = rows[0];
                    id = rec.id;
                    history.replaceState({}, '', `?id=${encodeURIComponent(id)}`);
                }
            }
            return rec
        }

        const datasummary = await syncCurrentFromURL();
        console.log(datasummary)

        /* ======================== Text utilities ======================== */
        const safeParse = (t) => { try { return JSON.parse(t); } catch { return null; } };
        const asArray = (v) => {
            if (Array.isArray(v)) return v;
            if (v == null) return [];
            if (typeof v === 'string') return v.split(/\n|,|;|\u2022/).map(s => s.trim()).filter(Boolean);
            return [String(v)];
        };
        function toTextFromResponse(rec) {
            const data = typeof rec.data === 'string' ? safeParse(rec.data) : rec.data;
            const a = data?.analysis ?? data ?? {};
            const lines = [];
            if (a.overall_match) lines.push('OVERALL: ' + a.overall_match);
            if (a.match_percentage != null) lines.push(`MATCH: ${a.match_percentage}%`);
            if (a.key_skills_exp_phrases_found_in_both)
                lines.push('FOUND: ' + asArray(a.key_skills_exp_phrases_found_in_both).join(', '));
            if (a.key_skills_exp_phrases_missing_from_resume_but_important_in_job)
                lines.push('MISSING: ' + asArray(a.key_skills_exp_phrases_missing_from_resume_but_important_in_job).join(', '));
            if (a.tailored_ats_optimized_resume)
                lines.push('TAILORED_RESUME:\n' + a.tailored_ats_optimized_resume);
            if (a.summary_and_tips) lines.push('TIPS: ' + a.summary_and_tips);
            return lines.join('\n');
        }

        // Build your context from the page state (current analysis on screen)
        function currentAnalysisContext() {
            // Example: read from ?id=‚Ä¶ and from your page variables
            const url = new URL(location.href);
            const id = Number(url.searchParams.get('id'));
            const label = datasummary.label || 'AI Response';
            // Optionally add short ‚Äútop chunks‚Äù or a summary string (keep it small)
            // const summary = await syncCurrentFromURL();
            let summary = toTextFromResponse(datasummary);
            console.log({ app: 'vereloop', responseId: id, responseLabel: label, summary })
            return { app: 'vereloop', responseId: id, responseLabel: label, summary };
        }

        // Initialize the chat with metadata (goes to n8n on every message)
        let chatWidget = createChat({
            webhookUrl: N8N_CHAT_WEBHOOK,
            target: '#n8n-chat',
            mode: 'fullscreen',
            loadPreviousSession: true,
            metadata: currentAnalysisContext(),   // <-- your context
            initialMessages: ['Hi there! üëã',
                'I am your Vereloop assistant.',
                'Ask me about this analysis.'],
        });

        // If the selected analysis changes on the page, reinitialize with fresh metadata
        function updateChatContext() {
            // Easiest way: re-create the widget (clear the container first)
            document.querySelector('#n8n-chat').innerHTML = '';
            chatWidget = createChat({
                webhookUrl: N8N_CHAT_WEBHOOK,
                target: '#n8n-chat',
                mode: 'window',
                loadPreviousSession: true,
                metadata: currentAnalysisContext(),
            });
        }

        // Call updateChatContext() whenever you switch to another saved response
        // e.g., after your viewer navigates to a new ?id=...
        window.addEventListener('locationchange', updateChatContext);
    </script>
</body>

</html>